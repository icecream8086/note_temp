graph TD
    %% 进程基础概念
    2_1_1["2.1.1+2.1.3 进程的概念、组成、特征"] --> 2_1_2["2.1.2 进程的状态与转换、进程的组织"]
    2_1_1 --> 2_1_4["2.1.4 进程控制"]
    2_1_1 --> 2_1_5["2.1.5 进程通信"]
    
    %% 线程相关
    2_1_6_1["2.1.6_1 线程的概念与特点"] --> 2_1_6_2["2.1.6_2 线程的实现方式和多线程模型"]
    2_1_6_1 --> 2_1_6_3["2.1.6_3 线程的状态与转换"]
    
    %% 调度层次
    2_2_1["2.2.1 调度的概念、层次"] --> 2_2_2["2.2.2 调度的目标（调度算法的评价指标）"]
    2_2_1 --> 2_2_3_1["2.2.3_1+2.2.5 进程调度的时机、切换与过程、方式"]
    2_2_1 --> 2_2_3_2["2.2.3_2 调度器和闲逛进程"]
    
    %% 调度算法
    2_2_2 --> 2_2_4_1["2.2.4_1 先来先服务、最短作业优先、最高响应比优先"]
    2_2_2 --> 2_2_4_2["2.2.4_2 时间片轮转、优先级、多级反馈队列"]
    2_2_2 --> 2_2_4_3["2.2.4_3 多级队列调度算法"]
    
    %% 同步互斥基础
    2_3_1["2.3.1 同步与互斥的基本概念"] --> 2_3_2_1["2.3.2_1 进程互斥的软件实现方法"]
    2_3_1 --> 2_3_2_2["2.3.2_2 进程互斥的硬件实现"]
    2_3_1 --> 2_3_3["2.3.3 互斥锁"]
    2_3_1 --> 2_3_4_1["2.3.4_1 信号量机制"]
    
    %% 信号量应用
    2_3_4_1 --> 2_3_4_2["2.3.4_2 用信号量实现进程互斥、同步、前驱关系"]
    2_3_4_2 --> 2_3_6_1["2.3.6_1 生产者-消费者问题"]
    2_3_6_1 --> 2_3_6_2["2.3.6_2 多生产者-多消费者"]
    2_3_4_2 --> 2_3_6_3["2.3.6_3 吸烟者问题"]
    2_3_4_2 --> 2_3_6_4["2.3.6_4 读者-写者问题"]
    2_3_4_2 --> 2_3_6_5["2.3.6_5 哲学家进餐问题"]
    
    %% 管程独立分支
    2_3_5["2.3.5 管程"]
    
    %% 死锁部分
    2_4_1["2.4.1 死锁的概念"] --> 2_4_2["2.4.2 死锁的处理策略—预防死锁"]
    2_4_1 --> 2_4_3["2.4.3 死锁的避免"]
    2_4_1 --> 2_4_4["2.4.4 死锁的检测与解除"]